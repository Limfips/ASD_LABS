#include <iostream>

/*
 * Lab_1:
 *
 * 1. Одномерный массив длинных целых чисел;
 * 2. Указатель на тип long int;
 * 3. Статический одномерный массив символов;
 * 4. Указатель на массив символов;
 * 5. Трехмерный массив целых чисел;
 * 6. Указатель на двумерный массив целых чисел.
 */


int main() {

    //ToDo это потом удалить
    int inc = 0;
    // mass size
    const int n = 5;


    // 1. Определить в функции main() переменные и массивы по таблице 1 в
    //  соответствии с вариантом (см. таблицу 1).
    long int massLongInt[n];
    long int *pLongIntValue;
    static char staticMassChar[n];
    char (*pStaticMassChar)[n];
    int threeDimensionalMass[2][2][3];
    int **pTwoDimensionalMass;

    // 2. В функции main() выполнить следующие действия:

    // 2.1. Проверить содержимое массива №1 (с помощью цикла for и
    //  операции вывода cout<<).
    for (long int value: massLongInt) {
        std::cout << value << std::endl;
    }

    // 2.2. Ввести данные в массив №1 (с помощью цикла for и операции ввода cin>>).
    for (long int & i : massLongInt) {
        // ToDo удрать тут комментарий и удалить тестовую логику
        i = ++inc;
//        std::cin >> i;
    }

    // 2.3. Еще раз проверить содержимое этого массива, сделать выводы.
    for (long int value: massLongInt) {
        std::cout << value << std::endl;
    }
    /*
     * Промежуточный вывод:
     *  Если массив не инициализировать, то происходит его инициализация по умолчанию (этап 2.1).
     *  Затем через цикл, используя ссылку на элемент массива, с клавиатуры вводятся
     *  значения для всех элементов массива(этап 2.2).
     *  В итоге мы проверяем правильность введённых значений (этап 2.3).
     */


    // 2.4. Присвоить указателю №2 адрес массива №1, вывести на экран адреса массива
    //  и указателя и содержимое указателя. Сделать выводы.
    pLongIntValue = massLongInt;
    std::cout << "Address mass: " << massLongInt << " - address p: " << pLongIntValue << std::endl;
    std::cout << "value mass[0]: " << *massLongInt << " - value *p: " << *pLongIntValue << std::endl;
    /*
     * Промежуточный вывод:
     *  Имя массива по сути является адресом его первого элемента.
     *  Но при этом имя массива это не стандартный указатель, и мы
     *  не можем изменить его адрес, но можем передать его в указатель.
     */


    // 2.5. Повторить пункт 3 для указателя, содержащего адрес массива. Сделать выводы.
    for(long int *ptr = massLongInt; ptr <= &massLongInt[n - 1]; ptr++)
    {
        std::cout << *ptr << std::endl;
    }
    /*
     * Промежуточный вывод:
     *  Здесь указатель ptr изначально указывает на первый элемент массива.
     *  с увеличением значения адреса на 1 (++), будет происходить
     *  перемещение по элементам массива.
     */


    // 2.6. Повторить пункты 1 – 3 для статического массива №3. Сделать выводы.
    for (char value: staticMassChar) {
        std::cout << "\'" << value << "\'" << std::endl;
    }
    // ToDo удалить тестовую логику
    inc = 70;
    for (char & i : staticMassChar) {
        // ToDo удрать тут комментарий и удалить тестовую логику
        i = (char) ++inc;
//        std::cin >> i;
    }
    for (char value: staticMassChar) {
        std::cout << "\'" << value << "\'" << std::endl;
    }
    /*
     * Промежуточный вывод:
     *  Использование ключевого слова static с локальными
     *  переменными изменяет их свойство продолжительности
     *  жизни с автоматического на статическое (или «фиксированное»).
     *  Это значит что, что она создается (и инициализируется)
     *  только один раз, а затем сохраняется на протяжении
     *  выполнения всей программы.
     *  Так как у нас массив char, то значения по умолчанию были пустые символы ' '.
     */


    // 2.7. Используя имеющийся указатель №2, создать динамический массив и повторить
    //  для него пункты 1 – 3. Сделать выводы.
    pLongIntValue = new long int[n]();
    for (int i = 0; i < n; i++)
    {
        std::cout << pLongIntValue[i] << std::endl;
    }
    inc = 10;
    for (int i = 0; i < n; i++) {
        // ToDo удрать тут комментарий и удалить тестовую логику
        pLongIntValue[i] = ++inc;
//        std::cin >> i;
    }
    for (int i = 0; i < n; i++)
    {
        std::cout << pLongIntValue[i] << std::endl;
    }
    /*
     * Промежуточный вывод:
     *  new long int[n]() - выделили памяти под
     *  динамический массив, используя оператор new.
     *  После, в квадратных скобках указали размерность массива.
     *  Динамические объекты существуют, пока не будут удалены явным образом.
     */


    // 2.8. Удалить динамический массив. Используя указатель №4, создать двумерный
    //  динамический массив и повторить для него пункты 2, 3. Сделать выводы.
    //  Удалить двумерный динамический массив.
    delete [] pLongIntValue;
    pStaticMassChar = new char[n][n]();
    inc = 70;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; ++j) {
            // ToDo удрать тут комментарий и удалить тестовую логику
            pStaticMassChar[i][j] = (char) ++inc;
//            std::cin >> i;
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; ++j) {
            std::cout << "\'" << pStaticMassChar[i][j] << "\'" << std::endl;
        }
    }
    delete [] pStaticMassChar;
    /*
     * Промежуточный вывод:
     *  После удаления динамического массива, освободилась его память.
     *  Удаляются многомерные динамические массивы также, как одномерные.
     */


    // 2.9. Вывести на экран любой из элементов трехмерного массива №5, используя
    //  операцию индексации.
    std::cout << *(*(*(threeDimensionalMass+1)+1)+1) << std::endl;


    // 2.10. Повторить пункт 9, используя имя массива как указатель и операцию
    //  доступа по указателю.
    std::cout << threeDimensionalMass[1][1][1] << std::endl;


    // 2.11. Присвоить указателю №6 на двумерный массив адрес трехмерного массива №5.
    //  Повторить для этого указателя пункт 10. Сделать выводы.
    pTwoDimensionalMass = reinterpret_cast<int **>(threeDimensionalMass);
    std::cout << pTwoDimensionalMass[1][1] << std::endl;

    //Преобразовал тип из трехмерного в двухмерный

    return 0;
}
